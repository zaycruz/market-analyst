"""
Email delivery module for Oracle reports.
Supports multiple delivery methods without external credentials:
- Local sendmail/mail command
- File-based delivery
- Mock mode for testing
"""

import asyncio
import logging
import os
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
from typing import Optional

import markdown
import resend

from backend.config.settings import settings

logger = logging.getLogger(__name__)


# Clean, professional HTML email template
EMAIL_CSS = """
<style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        line-height: 1.6;
        color: #1a1a1a;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
    }
    .container {
        background-color: #ffffff;
        border-radius: 8px;
        padding: 30px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
        color: #0d47a1;
        border-bottom: 3px solid #0d47a1;
        padding-bottom: 10px;
        margin-top: 0;
    }
    h2 {
        color: #1565c0;
        margin-top: 30px;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 8px;
    }
    h3 {
        color: #1976d2;
        margin-top: 20px;
    }
    table {
        border-collapse: collapse;
        width: 100%;
        margin: 15px 0;
        font-size: 14px;
    }
    th {
        background-color: #1565c0;
        color: white;
        padding: 12px 8px;
        text-align: left;
        font-weight: 600;
    }
    td {
        padding: 10px 8px;
        border-bottom: 1px solid #e0e0e0;
    }
    tr:nth-child(even) {
        background-color: #f8f9fa;
    }
    tr:hover {
        background-color: #e3f2fd;
    }
    strong {
        color: #0d47a1;
    }
    em {
        color: #666;
    }
    hr {
        border: none;
        border-top: 1px solid #e0e0e0;
        margin: 25px 0;
    }
    ul, ol {
        padding-left: 25px;
    }
    li {
        margin: 8px 0;
    }
    code {
        background-color: #f5f5f5;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 13px;
    }
    .bullish { color: #2e7d32; font-weight: bold; }
    .bearish { color: #c62828; font-weight: bold; }
    .neutral { color: #f57c00; font-weight: bold; }
    .footer {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #e0e0e0;
        font-size: 12px;
        color: #666;
        text-align: center;
    }
</style>
"""


def markdown_to_html(md_content: str) -> str:
    """Convert markdown content to styled HTML email."""
    # Convert markdown to HTML with table support
    html_body = markdown.markdown(
        md_content, extensions=["tables", "fenced_code", "nl2br"]
    )

    # Add color coding for market signals
    html_body = html_body.replace(">BULLISH<", ' class="bullish">BULLISH<')
    html_body = html_body.replace(">BEARISH<", ' class="bearish">BEARISH<')
    html_body = html_body.replace(">NEUTRAL<", ' class="neutral">NEUTRAL<')
    html_body = html_body.replace(">RISK_ON<", ' class="bullish">RISK_ON<')
    html_body = html_body.replace(">RISK_OFF<", ' class="bearish">RISK_OFF<')

    # Wrap in full HTML document
    html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    {EMAIL_CSS}
</head>
<body>
    <div class="container">
        {html_body}
        <div class="footer">
            Generated by Oracle Market Research Agent<br>
            {datetime.now().strftime("%Y-%m-%d %H:%M:%S ET")}
        </div>
    </div>
</body>
</html>"""

    return html


class EmailDelivery:
    """Handles sending reports via email without external credentials."""

    def __init__(self):
        self.enabled = settings.enable_email
        self.delivery_method = getattr(settings, "email_delivery_method", "auto")
        self.output_dir = getattr(settings, "email_output_dir", "./email_reports")
        self.from_addr = settings.email_from
        self.to_addr = settings.email_to
        self.subject_prefix = getattr(settings, "email_subject_prefix", "[ORACLE]")

        # Ensure output directory exists
        if self.delivery_method == "file":
            os.makedirs(self.output_dir, exist_ok=True)

    def _check_sendmail_available(self) -> bool:
        """Check if sendmail is available on the system."""
        return os.path.exists("/usr/sbin/sendmail") or os.path.exists(
            "/usr/bin/sendmail"
        )

    def _send_via_sendmail(self, msg: MIMEMultipart) -> bool:
        """Send email using local sendmail command."""
        try:
            import subprocess

            result = subprocess.run(
                ["sendmail", "-t", "-f", self.from_addr],
                input=msg.as_string(),
                capture_output=True,
                timeout=30,
            )
            if result.returncode == 0:
                logger.info("Email sent via sendmail")
                return True
            else:
                logger.error(f"Sendmail failed: {result.stderr.decode()}")
                return False
        except Exception as e:
            logger.error(f"Sendmail error: {e}")
            return False

    def _send_via_file(self, report_path: str, subject: str) -> bool:
        """Save report to file instead of sending."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"report_{timestamp}.txt"
            filepath = os.path.join(self.output_dir, filename)

            with open(filepath, "w") as f:
                f.write(f"To: {self.to_addr}\n")
                f.write(f"Subject: {subject}\n")
                f.write(f"Date: {datetime.now().isoformat()}\n")
                f.write("=" * 50 + "\n\n")

                # Add report content
                with open(report_path) as rf:
                    f.write(rf.read())

            logger.info(f"Report saved to {filepath}")
            return True
        except Exception as e:
            logger.error(f"File delivery error: {e}")
            return False

    def _send_via_smtp(self, msg: MIMEMultipart) -> bool:
        """Send email via SMTP with TLS/SSL support."""
        try:
            server = settings.smtp_server
            port = settings.smtp_port
            username = getattr(settings, "smtp_username", "")
            password = getattr(settings, "smtp_password", "")

            if port == 465:
                smtp = smtplib.SMTP_SSL(server, port)
            else:
                smtp = smtplib.SMTP(server, port)
                smtp.starttls()

            if username and password:
                smtp.login(username, password)

            smtp.send_message(msg)
            smtp.quit()

            logger.info("Email sent via SMTP")
            return True
        except Exception as e:
            logger.error(f"SMTP error: {e}")
            return False

    def _send_via_resend(
        self, subject: str, html_content: str, text_content: str, recipients: list
    ) -> bool:
        """Send email via Resend API."""
        try:
            api_key = getattr(settings, "resend_api_key", "")
            if not api_key:
                logger.error("Resend API key not configured")
                return False

            resend.api_key = api_key

            params = {
                "from": self.from_addr,
                "to": recipients,
                "subject": subject,
                "html": html_content,
                "text": text_content,
            }

            response = resend.Emails.send(params)
            logger.info(f"Email sent via Resend: {response}")
            return True
        except Exception as e:
            logger.error(f"Resend error: {e}")
            return False

    async def send_report(
        self,
        report_path: str,
        report_type: str = "daily",
        additional_recipients: Optional[list] = None,
    ) -> bool:
        """
        Send a report via email using credential-free methods.

        Args:
            report_path: Path to the markdown report file
            report_type: Type of report (daily, weekly)
            additional_recipients: Additional email addresses to send to

        Returns:
            True if delivery successful, False otherwise
        """
        if not self.enabled and self.delivery_method != "file":
            logger.warning("Email delivery is disabled")
            return False

        # Read report content
        path = Path(report_path)
        if not path.exists():
            logger.error(f"Report not found: {report_path}")
            return False

        # Build email
        msg = MIMEMultipart()
        msg["From"] = self.from_addr

        recipients = []
        if self.to_addr:
            recipients.extend(
                [addr.strip() for addr in self.to_addr.split(",") if addr.strip()]
            )
        if additional_recipients:
            recipients.extend(additional_recipients)

        if not recipients and self.delivery_method != "file":
            logger.error("No recipients configured")
            return False

        msg["To"] = ", ".join(recipients) if recipients else "undisclosed-recipients"

        # Subject
        date_str = datetime.now().strftime("%Y-%m-%d")
        if report_type == "daily":
            subject = f"{self.subject_prefix} Premarket Report - {date_str}"
        elif report_type == "evening":
            subject = f"{self.subject_prefix} Post-Market Report - {date_str}"
        else:
            subject = f"{self.subject_prefix} {report_type.title()} Report - {date_str}"

        msg["Subject"] = subject

        with open(path) as f:
            content = f.read()

        html_content = markdown_to_html(content)
        msg.attach(MIMEText(html_content, "html"))
        msg.attach(MIMEText(content, "plain"))

        if self.delivery_method == "resend":
            return self._send_via_resend(subject, html_content, content, recipients)

        elif self.delivery_method == "auto":
            if self._check_sendmail_available():
                return self._send_via_sendmail(msg)
            elif self.to_addr:
                return self._send_via_smtp(msg)
            else:
                return self._send_via_file(report_path, subject)

        elif self.delivery_method == "sendmail":
            return self._send_via_sendmail(msg)

        elif self.delivery_method == "file":
            return self._send_via_file(report_path, subject)

        elif self.delivery_method == "smtp" and self.to_addr:
            return self._send_via_smtp(msg)

        else:
            logger.error(f"Unknown delivery method: {self.delivery_method}")
            return False

    async def send_premarket_report(self, date: Optional[str] = None) -> bool:
        """Send premarket daily report."""
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        report_path = f"{settings.reports_dir}/daily/{date}.md"
        return await self.send_report(report_path, report_type="daily")

    async def send_postmarket_report(self, date: Optional[str] = None) -> bool:
        """Send post-market daily report."""
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        report_path = f"{settings.reports_dir}/daily/{date}.md"
        return await self.send_report(report_path, report_type="evening")


# Singleton instance
email_delivery = EmailDelivery()


async def send_report_email(
    report_path: str, report_type: str = "daily", recipients: Optional[list] = None
) -> bool:
    """Convenience function to send a report."""
    return await email_delivery.send_report(
        report_path=report_path,
        report_type=report_type,
        additional_recipients=recipients,
    )
